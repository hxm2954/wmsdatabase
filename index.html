<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Database Schema ERD</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo, useCallback } = React;

    const domainColors = {
      core: { header: '#1e40af', bg: '#eff6ff', border: '#bfdbfe', light: '#dbeafe' },
      rbac: { header: '#7c3aed', bg: '#f5f3ff', border: '#c4b5fd', light: '#ede9fe' },
      chat: { header: '#059669', bg: '#ecfdf5', border: '#a7f3d0', light: '#d1fae5' },
      database: { header: '#d97706', bg: '#fffbeb', border: '#fcd34d', light: '#fef3c7' },
      query: { header: '#dc2626', bg: '#fef2f2', border: '#fecaca', light: '#fee2e2' },
      dashboard: { header: '#0891b2', bg: '#ecfeff', border: '#a5f3fc', light: '#cffafe' },
      playlist: { header: '#be185d', bg: '#fdf2f8', border: '#f9a8d4', light: '#fce7f3' },
      ai: { header: '#4f46e5', bg: '#eef2ff', border: '#a5b4fc', light: '#e0e7ff' }
    };

    const tables = {
      organizations: {
        domain: 'core',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'text' },
          { name: 'created_at', type: 'timestamptz' }
        ]
      },
      sites: {
        domain: 'core',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'text' },
          { name: 'organization_id', type: 'uuid', isFK: true },
          { name: 'created_at', type: 'timestamptz' }
        ]
      },
      users: {
        domain: 'core',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'email', type: 'text' },
          { name: 'name', type: 'text' },
          { name: 'role', type: 'text' },
          { name: 'organization_id', type: 'uuid', isFK: true },
          { name: 'site_id', type: 'uuid', isFK: true },
          { name: 'role_id', type: 'uuid', isFK: true },
          { name: 'status', type: 'varchar' }
        ]
      },
      user_organizations: {
        domain: 'core',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'user_id', type: 'uuid', isFK: true },
          { name: 'organization_id', type: 'uuid', isFK: true },
          { name: 'is_primary', type: 'bool' }
        ]
      },
      user_sites: {
        domain: 'core',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'user_id', type: 'uuid', isFK: true },
          { name: 'site_id', type: 'uuid', isFK: true },
          { name: 'is_primary', type: 'bool' }
        ]
      },
      roles: {
        domain: 'rbac',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'varchar', isUnique: true },
          { name: 'description', type: 'text' },
          { name: 'is_system', type: 'bool' }
        ]
      },
      role_permissions: {
        domain: 'rbac',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'role_id', type: 'uuid', isFK: true },
          { name: 'resource_type', type: 'varchar' },
          { name: 'action', type: 'varchar' },
          { name: 'scope', type: 'text' }
        ]
      },
      chat_sessions: {
        domain: 'chat',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'title', type: 'text' },
          { name: 'is_active', type: 'bool' },
          { name: 'created_by', type: 'uuid', isFK: true }
        ]
      },
      chat_messages: {
        domain: 'chat',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'session_id', type: 'uuid', isFK: true },
          { name: 'sender_type', type: 'text' },
          { name: 'content', type: 'text' },
          { name: 'query_id', type: 'uuid', isFK: true },
          { name: 'widget_id', type: 'uuid', isFK: true }
        ]
      },
      database_connections: {
        domain: 'database',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'varchar' },
          { name: 'type', type: 'varchar' },
          { name: 'details', type: 'jsonb' },
          { name: 'created_by', type: 'uuid', isFK: true }
        ]
      },
      database_table_access: {
        domain: 'database',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'connection_id', type: 'uuid', isFK: true },
          { name: 'table_name', type: 'text' },
          { name: 'schema_name', type: 'text' },
          { name: 'has_access', type: 'bool' }
        ]
      },
      contexts: {
        domain: 'query',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'varchar' },
          { name: 'content', type: 'text' },
          { name: 'created_by', type: 'uuid', isFK: true }
        ]
      },
      context_chunks: {
        domain: 'query',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'context_id', type: 'uuid', isFK: true },
          { name: 'content', type: 'text' },
          { name: 'order_index', type: 'int4' }
        ]
      },
      sql_queries: {
        domain: 'query',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'user_id', type: 'uuid', isFK: true },
          { name: 'connection_id', type: 'uuid', isFK: true },
          { name: 'context_id', type: 'uuid', isFK: true },
          { name: 'original_question', type: 'text' },
          { name: 'status', type: 'varchar' }
        ]
      },
      sql_query_attempts: {
        domain: 'query',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'query_id', type: 'uuid', isFK: true },
          { name: 'attempt_number', type: 'int4' },
          { name: 'generated_sql', type: 'text' },
          { name: 'has_results', type: 'bool' }
        ]
      },
      sql_query_feedback: {
        domain: 'query',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'query_id', type: 'uuid', isFK: true },
          { name: 'user_id', type: 'uuid', isFK: true },
          { name: 'feedback_type', type: 'text' }
        ]
      },
      sql_usage_metrics: {
        domain: 'query',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'user_id', type: 'uuid', isFK: true },
          { name: 'query_count', type: 'int4' },
          { name: 'year', type: 'int4' },
          { name: 'month', type: 'int4' }
        ]
      },
      dashboards: {
        domain: 'dashboard',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'text' },
          { name: 'description', type: 'text' },
          { name: 'layout_config', type: 'jsonb' },
          { name: 'created_by', type: 'uuid', isFK: true }
        ]
      },
      widgets: {
        domain: 'dashboard',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'text' },
          { name: 'type', type: 'text' },
          { name: 'config', type: 'jsonb' },
          { name: 'query_id', type: 'uuid', isFK: true },
          { name: 'session_id', type: 'uuid', isFK: true },
          { name: 'created_by', type: 'uuid', isFK: true }
        ]
      },
      dashboard_widgets: {
        domain: 'dashboard',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'dashboard_id', type: 'uuid', isFK: true },
          { name: 'widget_id', type: 'uuid', isFK: true },
          { name: 'position_x', type: 'int4' },
          { name: 'position_y', type: 'int4' }
        ]
      },
      playlists: {
        domain: 'playlist',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'name', type: 'text' },
          { name: 'share_token', type: 'text', isUnique: true },
          { name: 'is_public', type: 'bool' },
          { name: 'created_by', type: 'uuid', isFK: true }
        ]
      },
      playlist_dashboards: {
        domain: 'playlist',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'playlist_id', type: 'uuid', isFK: true },
          { name: 'dashboard_id', type: 'uuid', isFK: true },
          { name: 'order_index', type: 'int4' }
        ]
      },
      llm_configurations: {
        domain: 'ai',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'provider', type: 'varchar' },
          { name: 'model', type: 'varchar' },
          { name: 'api_key', type: 'text' },
          { name: 'is_default', type: 'bool' }
        ]
      },
      schema_vector_stores: {
        domain: 'ai',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'connection_id', type: 'uuid', isFK: true },
          { name: 'store_name', type: 'text' },
          { name: 'model_name', type: 'text' }
        ]
      },
      schema_vectors: {
        domain: 'ai',
        columns: [
          { name: 'id', type: 'uuid', isPK: true },
          { name: 'vector_store_id', type: 'uuid', isFK: true },
          { name: 'table_name', type: 'text' },
          { name: 'chunk_text', type: 'text' }
        ]
      }
    };

    // Relationships: from (FK table) -> to (PK table)
    // Arrow points FROM the FK table TO the PK table
    const relationships = [
      { from: 'sites', fromCol: 'organization_id', to: 'organizations', toCol: 'id' },
      { from: 'users', fromCol: 'site_id', to: 'sites', toCol: 'id' },
      { from: 'users', fromCol: 'role_id', to: 'roles', toCol: 'id' },
      { from: 'user_organizations', fromCol: 'organization_id', to: 'organizations', toCol: 'id' },
      { from: 'user_sites', fromCol: 'site_id', to: 'sites', toCol: 'id' },
      { from: 'role_permissions', fromCol: 'role_id', to: 'roles', toCol: 'id' },
      { from: 'chat_messages', fromCol: 'session_id', to: 'chat_sessions', toCol: 'id' },
      { from: 'database_table_access', fromCol: 'connection_id', to: 'database_connections', toCol: 'id' },
      { from: 'context_chunks', fromCol: 'context_id', to: 'contexts', toCol: 'id' },
      { from: 'sql_queries', fromCol: 'connection_id', to: 'database_connections', toCol: 'id' },
      { from: 'sql_queries', fromCol: 'context_id', to: 'contexts', toCol: 'id' },
      { from: 'sql_query_attempts', fromCol: 'query_id', to: 'sql_queries', toCol: 'id' },
      { from: 'sql_query_feedback', fromCol: 'query_id', to: 'sql_queries', toCol: 'id' },
      { from: 'widgets', fromCol: 'query_id', to: 'sql_queries', toCol: 'id' },
      { from: 'widgets', fromCol: 'session_id', to: 'chat_sessions', toCol: 'id' },
      { from: 'dashboard_widgets', fromCol: 'dashboard_id', to: 'dashboards', toCol: 'id' },
      { from: 'dashboard_widgets', fromCol: 'widget_id', to: 'widgets', toCol: 'id' },
      { from: 'playlist_dashboards', fromCol: 'playlist_id', to: 'playlists', toCol: 'id' },
      { from: 'playlist_dashboards', fromCol: 'dashboard_id', to: 'dashboards', toCol: 'id' },
      { from: 'schema_vector_stores', fromCol: 'connection_id', to: 'database_connections', toCol: 'id' },
      { from: 'schema_vectors', fromCol: 'vector_store_id', to: 'schema_vector_stores', toCol: 'id' },
    ];

    // Optimized initial positions with more spacing for clean routing
    const initialPositions = {
      // Row 1: Core + RBAC
      organizations: { x: 80, y: 80 },
      sites: { x: 320, y: 80 },
      users: { x: 560, y: 80 },
      roles: { x: 900, y: 80 },
      role_permissions: { x: 1140, y: 80 },
      
      // Row 2: User junction tables
      user_organizations: { x: 80, y: 320 },
      user_sites: { x: 320, y: 320 },
      
      // Row 2-3: Chat
      chat_sessions: { x: 900, y: 320 },
      chat_messages: { x: 1140, y: 320 },
      
      // Row 3: Database
      database_connections: { x: 80, y: 540 },
      database_table_access: { x: 80, y: 760 },
      
      // Row 3-4: Query system (center)
      contexts: { x: 320, y: 540 },
      context_chunks: { x: 320, y: 760 },
      sql_queries: { x: 560, y: 540 },
      sql_query_attempts: { x: 560, y: 760 },
      sql_query_feedback: { x: 800, y: 760 },
      sql_usage_metrics: { x: 560, y: 960 },
      
      // Row 3-4: Dashboard
      dashboards: { x: 1040, y: 540 },
      widgets: { x: 1040, y: 760 },
      dashboard_widgets: { x: 1280, y: 650 },
      
      // Row 4: Playlist
      playlists: { x: 1280, y: 400 },
      playlist_dashboards: { x: 1280, y: 870 },
      
      // Row 5: AI
      llm_configurations: { x: 80, y: 960 },
      schema_vector_stores: { x: 320, y: 960 },
      schema_vectors: { x: 320, y: 1160 },
    };

    const TABLE_WIDTH = 200;
    const ROW_HEIGHT = 26;
    const HEADER_HEIGHT = 36;
    const PADDING = 30;

    const TableCard = ({ name, data, position, onDrag, isHighlighted, highlightedCols, onMouseEnter, onMouseLeave }) => {
      const [isDragging, setIsDragging] = useState(false);
      const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
      const colors = domainColors[data.domain];

      const handleMouseDown = (e) => {
        if (e.target.closest('.table-header')) {
          e.preventDefault();
          setIsDragging(true);
          setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y });
        }
      };

      useEffect(() => {
        if (!isDragging) return;
        
        const handleMouseMove = (e) => {
          onDrag(name, { 
            x: Math.max(0, e.clientX - dragStart.x), 
            y: Math.max(0, e.clientY - dragStart.y) 
          });
        };
        
        const handleMouseUp = () => setIsDragging(false);
        
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isDragging, dragStart, name, onDrag]);

      const tableHeight = HEADER_HEIGHT + data.columns.length * ROW_HEIGHT;

      return (
        <div
          onMouseEnter={onMouseEnter}
          onMouseLeave={onMouseLeave}
          style={{
            position: 'absolute',
            left: position.x,
            top: position.y,
            width: TABLE_WIDTH,
            background: '#ffffff',
            borderRadius: '8px',
            boxShadow: isHighlighted 
              ? `0 0 0 3px ${colors.header}, 0 10px 40px rgba(0,0,0,0.2)` 
              : '0 2px 8px rgba(0,0,0,0.08)',
            border: `1px solid ${isHighlighted ? colors.header : '#e2e8f0'}`,
            fontSize: '12px',
            overflow: 'hidden',
            transition: 'box-shadow 0.2s, border-color 0.2s',
            zIndex: isDragging ? 1000 : (isHighlighted ? 100 : 1),
            cursor: isDragging ? 'grabbing' : 'default'
          }}
        >
          <div
            className="table-header"
            onMouseDown={handleMouseDown}
            style={{
              background: colors.header,
              color: 'white',
              padding: '10px 12px',
              fontWeight: '600',
              fontSize: '12px',
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              cursor: isDragging ? 'grabbing' : 'grab',
              userSelect: 'none'
            }}
          >
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <line x1="3" y1="9" x2="21" y2="9"/>
            </svg>
            {name}
          </div>
          <div>
            {data.columns.map((col, i) => {
              const isHighlightedCol = highlightedCols?.includes(col.name);
              return (
                <div
                  key={col.name}
                  data-table={name}
                  data-column={col.name}
                  style={{
                    padding: '6px 12px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px',
                    background: isHighlightedCol ? colors.light : (i % 2 === 0 ? '#fafafa' : '#ffffff'),
                    borderLeft: isHighlightedCol ? `4px solid ${colors.header}` : '4px solid transparent',
                    transition: 'all 0.15s'
                  }}
                >
                  <span style={{ width: '18px', display: 'flex', justifyContent: 'center' }}>
                    {col.isPK && <span style={{ fontSize: '12px' }}>ðŸ”‘</span>}
                    {col.isFK && !col.isPK && <span style={{ color: '#8b5cf6', fontSize: '14px', fontWeight: 'bold' }}>â€º</span>}
                    {col.isUnique && !col.isPK && <span style={{ color: '#10b981', fontSize: '10px' }}>â—‰</span>}
                  </span>
                  <span style={{ 
                    flex: 1, 
                    fontWeight: col.isPK ? '600' : '400', 
                    color: '#1e293b',
                    fontFamily: 'monospace',
                    fontSize: '11px'
                  }}>
                    {col.name}
                  </span>
                  <span style={{ 
                    color: '#94a3b8', 
                    fontFamily: 'monospace',
                    fontSize: '10px'
                  }}>
                    {col.type}
                  </span>
                </div>
              );
            })}
          </div>
        </div>
      );
    };

    const App = () => {
      const [positions, setPositions] = useState(initialPositions);
      const [hoveredTable, setHoveredTable] = useState(null);
      const [scale, setScale] = useState(0.9);
      const canvasRef = useRef(null);

      const handleDrag = useCallback((name, newPos) => {
        setPositions(prev => ({ ...prev, [name]: newPos }));
      }, []);

      // Get table bounds
      const getTableBounds = useCallback((tableName) => {
        const pos = positions[tableName];
        const table = tables[tableName];
        const height = HEADER_HEIGHT + table.columns.length * ROW_HEIGHT;
        return {
          left: pos.x,
          right: pos.x + TABLE_WIDTH,
          top: pos.y,
          bottom: pos.y + height,
          centerX: pos.x + TABLE_WIDTH / 2,
          centerY: pos.y + height / 2
        };
      }, [positions]);

      // Get column Y position
      const getColY = useCallback((tableName, colName) => {
        const pos = positions[tableName];
        const table = tables[tableName];
        const colIndex = table.columns.findIndex(c => c.name === colName);
        return pos.y + HEADER_HEIGHT + colIndex * ROW_HEIGHT + ROW_HEIGHT / 2;
      }, [positions]);

      // Smart routing that avoids tables
      const routeConnection = useCallback((fromTable, fromCol, toTable, toCol, allPositions, index) => {
        const fromBounds = getTableBounds(fromTable);
        const toBounds = getTableBounds(toTable);
        const fromY = getColY(fromTable, fromCol);
        const toY = getColY(toTable, toCol);
        
        // Determine connection sides based on relative positions
        let fromX, toX, fromSide, toSide;
        
        const horizontalGap = toBounds.left - fromBounds.right;
        const reverseGap = fromBounds.left - toBounds.right;
        
        if (horizontalGap > 40) {
          // To is to the right - connect from right to left
          fromX = fromBounds.right;
          toX = toBounds.left;
          fromSide = 'right';
          toSide = 'left';
        } else if (reverseGap > 40) {
          // To is to the left - connect from left to right
          fromX = fromBounds.left;
          toX = toBounds.right;
          fromSide = 'left';
          toSide = 'right';
        } else {
          // Tables are overlapping horizontally - use outer edges
          if (fromBounds.centerX < toBounds.centerX) {
            fromX = fromBounds.right;
            toX = toBounds.right;
            fromSide = 'right';
            toSide = 'right';
          } else {
            fromX = fromBounds.left;
            toX = toBounds.left;
            fromSide = 'left';
            toSide = 'left';
          }
        }
        
        // Calculate routing with offset to avoid overlapping lines
        const offset = (index % 5) * 8;
        const baseOffset = 25 + offset;
        
        let path;
        
        if (fromSide === 'right' && toSide === 'left') {
          // Standard left-to-right routing
          const midX = fromX + (toX - fromX) / 2;
          if (Math.abs(fromY - toY) < 5) {
            // Nearly horizontal - straight line
            path = `M ${fromX} ${fromY} L ${toX} ${toY}`;
          } else {
            // Orthogonal routing
            path = `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${toY} L ${toX} ${toY}`;
          }
        } else if (fromSide === 'left' && toSide === 'right') {
          // Right-to-left routing
          const midX = Math.min(fromX, toX) - baseOffset;
          path = `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${toY} L ${toX} ${toY}`;
        } else if (fromSide === toSide) {
          // Same side routing - go around
          const outX = fromSide === 'right' 
            ? Math.max(fromX, toX) + baseOffset 
            : Math.min(fromX, toX) - baseOffset;
          path = `M ${fromX} ${fromY} L ${outX} ${fromY} L ${outX} ${toY} L ${toX} ${toY}`;
        }
        
        return { path, fromX, fromY, toX, toY };
      }, [getTableBounds, getColY]);

      // Active relationships on hover
      const activeRels = hoveredTable 
        ? relationships.filter(r => r.from === hoveredTable || r.to === hoveredTable)
        : [];

      const getHighlightedCols = (tableName) => {
        if (!hoveredTable) return [];
        return activeRels
          .filter(r => r.from === tableName || r.to === tableName)
          .map(r => r.from === tableName ? r.fromCol : r.toCol);
      };

      const resetPositions = () => setPositions(initialPositions);

      return (
        <div style={{ width: '100vw', height: '100vh', overflow: 'hidden', background: '#f8fafc' }}>
          {/* Header */}
          <div style={{ 
            background: 'white', 
            padding: '10px 20px', 
            borderBottom: '1px solid #e2e8f0',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            zIndex: 1000
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
              <h1 style={{ fontSize: '16px', fontWeight: '600', color: '#1e293b' }}>
                ðŸ“Š Database Schema ERD
              </h1>
              <span style={{ fontSize: '11px', color: '#64748b', background: '#f1f5f9', padding: '4px 10px', borderRadius: '4px' }}>
                {Object.keys(tables).length} tables â€¢ {relationships.length} relationships
              </span>
            </div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px', fontSize: '10px', color: '#64748b' }}>
                <span>ðŸ”‘ PK</span>
                <span style={{ color: '#8b5cf6' }}>â€º FK</span>
                <span>â—‰ Unique</span>
              </div>
              <div style={{ height: '20px', width: '1px', background: '#e2e8f0' }} />
              <button 
                onClick={resetPositions}
                style={{ 
                  padding: '6px 12px', 
                  border: '1px solid #e2e8f0', 
                  borderRadius: '6px', 
                  background: 'white', 
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: '#64748b'
                }}
              >
                Reset Layout
              </button>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <button 
                  onClick={() => setScale(s => Math.max(0.4, s - 0.1))} 
                  style={{ width: '28px', height: '28px', border: '1px solid #e2e8f0', borderRadius: '6px', background: 'white', cursor: 'pointer', fontSize: '14px' }}
                >âˆ’</button>
                <span style={{ fontSize: '11px', color: '#64748b', minWidth: '40px', textAlign: 'center' }}>{Math.round(scale * 100)}%</span>
                <button 
                  onClick={() => setScale(s => Math.min(1.5, s + 0.1))} 
                  style={{ width: '28px', height: '28px', border: '1px solid #e2e8f0', borderRadius: '6px', background: 'white', cursor: 'pointer', fontSize: '14px' }}
                >+</button>
              </div>
            </div>
          </div>

          {/* Multi-tenancy note */}
          <div style={{
            position: 'fixed',
            top: '56px',
            left: '20px',
            background: '#fef3c7',
            border: '1px solid #fcd34d',
            borderRadius: '6px',
            padding: '6px 10px',
            fontSize: '10px',
            color: '#92400e',
            zIndex: 999
          }}>
            <strong>Note:</strong> Most tables have <code style={{ background: '#fde68a', padding: '1px 3px', borderRadius: '2px' }}>organization_id</code> & <code style={{ background: '#fde68a', padding: '1px 3px', borderRadius: '2px' }}>site_id</code> (connections hidden to reduce clutter)
          </div>

          {/* Canvas */}
          <div 
            ref={canvasRef}
            style={{ 
              marginTop: '48px',
              width: '100%', 
              height: 'calc(100vh - 48px)', 
              overflow: 'auto',
              position: 'relative'
            }}
          >
            <div style={{ 
              transform: `scale(${scale})`, 
              transformOrigin: 'top left',
              position: 'relative',
              width: '1600px',
              height: '1400px',
              background: '#f8fafc'
            }}>
              {/* SVG for connection lines - rendered BEHIND tables */}
              <svg style={{ 
                position: 'absolute', 
                top: 0, 
                left: 0, 
                width: '100%', 
                height: '100%', 
                pointerEvents: 'none',
                zIndex: 0
              }}>
                <defs>
                  {/* Arrow markers for each domain color */}
                  {Object.entries(domainColors).map(([domain, colors]) => (
                    <marker 
                      key={`arrow-${domain}`} 
                      id={`arrow-${domain}`} 
                      markerWidth="12" 
                      markerHeight="10" 
                      refX="10" 
                      refY="5" 
                      orient="auto"
                      markerUnits="userSpaceOnUse"
                    >
                      <path d="M 0 0 L 12 5 L 0 10 L 3 5 Z" fill={colors.header} />
                    </marker>
                  ))}
                  <marker 
                    id="arrow-gray" 
                    markerWidth="10" 
                    markerHeight="8" 
                    refX="9" 
                    refY="4" 
                    orient="auto"
                    markerUnits="userSpaceOnUse"
                  >
                    <path d="M 0 0 L 10 4 L 0 8 L 2 4 Z" fill="#cbd5e1" />
                  </marker>
                  {/* Circle markers for FK end */}
                  {Object.entries(domainColors).map(([domain, colors]) => (
                    <marker 
                      key={`circle-${domain}`} 
                      id={`circle-${domain}`} 
                      markerWidth="8" 
                      markerHeight="8" 
                      refX="4" 
                      refY="4" 
                      orient="auto"
                      markerUnits="userSpaceOnUse"
                    >
                      <circle cx="4" cy="4" r="3" fill={colors.header} />
                    </marker>
                  ))}
                </defs>
                
                {relationships.map((rel, index) => {
                  const isActive = hoveredTable ? activeRels.includes(rel) : false;
                  const isVisible = !hoveredTable || isActive;
                  const route = routeConnection(rel.from, rel.fromCol, rel.to, rel.toCol, positions, index);
                  const domain = tables[rel.from].domain;
                  const color = isActive ? domainColors[domain].header : '#cbd5e1';
                  
                  return (
                    <g key={`${rel.from}-${rel.fromCol}-${rel.to}-${rel.toCol}`} style={{ opacity: isVisible ? 1 : 0.15 }}>
                      <path
                        d={route.path}
                        fill="none"
                        stroke={color}
                        strokeWidth={isActive ? 2.5 : 1.5}
                        markerStart={isActive ? `url(#circle-${domain})` : ''}
                        markerEnd={isActive ? `url(#arrow-${domain})` : 'url(#arrow-gray)'}
                        style={{ transition: 'opacity 0.2s' }}
                      />
                    </g>
                  );
                })}
              </svg>

              {/* Table cards */}
              {Object.entries(tables).map(([name, data]) => (
                <TableCard
                  key={name}
                  name={name}
                  data={data}
                  position={positions[name]}
                  onDrag={handleDrag}
                  isHighlighted={hoveredTable === name || activeRels.some(r => r.from === name || r.to === name)}
                  highlightedCols={getHighlightedCols(name)}
                  onMouseEnter={() => setHoveredTable(name)}
                  onMouseLeave={() => setHoveredTable(null)}
                />
              ))}
            </div>
          </div>

          {/* Legend */}
          <div style={{
            position: 'fixed',
            bottom: '12px',
            right: '12px',
            background: 'white',
            borderRadius: '8px',
            padding: '10px 14px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
            fontSize: '10px',
            zIndex: 999
          }}>
            <div style={{ fontWeight: '600', marginBottom: '6px', color: '#475569' }}>Domains</div>
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '3px 14px' }}>
              {Object.entries({
                core: 'Core Identity',
                rbac: 'Access Control', 
                chat: 'Chat',
                database: 'Database',
                query: 'Query System',
                dashboard: 'Dashboards',
                playlist: 'Playlists',
                ai: 'AI / Vectors'
              }).map(([domain, label]) => (
                <div key={domain} style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                  <div style={{ width: '10px', height: '10px', borderRadius: '2px', background: domainColors[domain].header }} />
                  <span style={{ color: '#64748b' }}>{label}</span>
                </div>
              ))}
            </div>
          </div>

          {/* Instructions */}
          <div style={{
            position: 'fixed',
            bottom: '12px',
            left: '50%',
            transform: 'translateX(-50%)',
            background: 'white',
            padding: '8px 16px',
            borderRadius: '8px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
            fontSize: '11px',
            color: '#64748b',
            zIndex: 999
          }}>
            ðŸ’¡ <strong>Drag</strong> table headers to move â€¢ <strong>Hover</strong> to highlight relationships â€¢ Arrow points from FK â†’ PK
          </div>
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
